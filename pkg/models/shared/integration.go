// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"errors"
	"fmt"
	"github.com/unified-to/unified-go-sdk/pkg/utils"
	"time"
)

type Integration1 struct {
}

func (i Integration1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *Integration1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, nil); err != nil {
		return err
	}
	return nil
}

type Integration5Type string

const (
	Integration5TypeIntegration1 Integration5Type = "Integration_1"
	Integration5TypeStr          Integration5Type = "str"
	Integration5TypeNumber       Integration5Type = "number"
	Integration5TypeBoolean      Integration5Type = "boolean"
)

type Integration5 struct {
	Integration1 *Integration1 `queryParam:"inline" union:"member"`
	Str          *string       `queryParam:"inline" union:"member"`
	Number       *float64      `queryParam:"inline" union:"member"`
	Boolean      *bool         `queryParam:"inline" union:"member"`

	Type Integration5Type
}

func CreateIntegration5Integration1(integration1 Integration1) Integration5 {
	typ := Integration5TypeIntegration1

	return Integration5{
		Integration1: &integration1,
		Type:         typ,
	}
}

func CreateIntegration5Str(str string) Integration5 {
	typ := Integration5TypeStr

	return Integration5{
		Str:  &str,
		Type: typ,
	}
}

func CreateIntegration5Number(number float64) Integration5 {
	typ := Integration5TypeNumber

	return Integration5{
		Number: &number,
		Type:   typ,
	}
}

func CreateIntegration5Boolean(boolean bool) Integration5 {
	typ := Integration5TypeBoolean

	return Integration5{
		Boolean: &boolean,
		Type:    typ,
	}
}

func (u *Integration5) UnmarshalJSON(data []byte) error {

	var integration1 Integration1 = Integration1{}
	if err := utils.UnmarshalJSON(data, &integration1, "", true, nil); err == nil {
		u.Integration1 = &integration1
		u.Type = Integration5TypeIntegration1
		return nil
	}

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		u.Str = &str
		u.Type = Integration5TypeStr
		return nil
	}

	var number float64 = float64(0)
	if err := utils.UnmarshalJSON(data, &number, "", true, nil); err == nil {
		u.Number = &number
		u.Type = Integration5TypeNumber
		return nil
	}

	var boolean bool = false
	if err := utils.UnmarshalJSON(data, &boolean, "", true, nil); err == nil {
		u.Boolean = &boolean
		u.Type = Integration5TypeBoolean
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for Integration5", string(data))
}

func (u Integration5) MarshalJSON() ([]byte, error) {
	if u.Integration1 != nil {
		return utils.MarshalJSON(u.Integration1, "", true)
	}

	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.Number != nil {
		return utils.MarshalJSON(u.Number, "", true)
	}

	if u.Boolean != nil {
		return utils.MarshalJSON(u.Boolean, "", true)
	}

	return nil, errors.New("could not marshal union type Integration5: all fields are null")
}

type APIType string

const (
	APITypeMapOfAny            APIType = "mapOfAny"
	APITypeStr                 APIType = "str"
	APITypeNumber              APIType = "number"
	APITypeBoolean             APIType = "boolean"
	APITypeArrayOfIntegration5 APIType = "arrayOfIntegration5"
)

type API struct {
	MapOfAny            map[string]any `queryParam:"inline" union:"member"`
	Str                 *string        `queryParam:"inline" union:"member"`
	Number              *float64       `queryParam:"inline" union:"member"`
	Boolean             *bool          `queryParam:"inline" union:"member"`
	ArrayOfIntegration5 []Integration5 `queryParam:"inline" union:"member"`

	Type APIType
}

func CreateAPIMapOfAny(mapOfAny map[string]any) API {
	typ := APITypeMapOfAny

	return API{
		MapOfAny: mapOfAny,
		Type:     typ,
	}
}

func CreateAPIStr(str string) API {
	typ := APITypeStr

	return API{
		Str:  &str,
		Type: typ,
	}
}

func CreateAPINumber(number float64) API {
	typ := APITypeNumber

	return API{
		Number: &number,
		Type:   typ,
	}
}

func CreateAPIBoolean(boolean bool) API {
	typ := APITypeBoolean

	return API{
		Boolean: &boolean,
		Type:    typ,
	}
}

func CreateAPIArrayOfIntegration5(arrayOfIntegration5 []Integration5) API {
	typ := APITypeArrayOfIntegration5

	return API{
		ArrayOfIntegration5: arrayOfIntegration5,
		Type:                typ,
	}
}

func (u *API) UnmarshalJSON(data []byte) error {

	var mapOfAny map[string]any = map[string]any{}
	if err := utils.UnmarshalJSON(data, &mapOfAny, "", true, nil); err == nil {
		u.MapOfAny = mapOfAny
		u.Type = APITypeMapOfAny
		return nil
	}

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		u.Str = &str
		u.Type = APITypeStr
		return nil
	}

	var number float64 = float64(0)
	if err := utils.UnmarshalJSON(data, &number, "", true, nil); err == nil {
		u.Number = &number
		u.Type = APITypeNumber
		return nil
	}

	var boolean bool = false
	if err := utils.UnmarshalJSON(data, &boolean, "", true, nil); err == nil {
		u.Boolean = &boolean
		u.Type = APITypeBoolean
		return nil
	}

	var arrayOfIntegration5 []Integration5 = []Integration5{}
	if err := utils.UnmarshalJSON(data, &arrayOfIntegration5, "", true, nil); err == nil {
		u.ArrayOfIntegration5 = arrayOfIntegration5
		u.Type = APITypeArrayOfIntegration5
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for API", string(data))
}

func (u API) MarshalJSON() ([]byte, error) {
	if u.MapOfAny != nil {
		return utils.MarshalJSON(u.MapOfAny, "", true)
	}

	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.Number != nil {
		return utils.MarshalJSON(u.Number, "", true)
	}

	if u.Boolean != nil {
		return utils.MarshalJSON(u.Boolean, "", true)
	}

	if u.ArrayOfIntegration5 != nil {
		return utils.MarshalJSON(u.ArrayOfIntegration5, "", true)
	}

	return nil, errors.New("could not marshal union type API: all fields are null")
}

type IntegrationSchemas1 struct {
}

func (i IntegrationSchemas1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *IntegrationSchemas1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, nil); err != nil {
		return err
	}
	return nil
}

type IntegrationSchemas5Type string

const (
	IntegrationSchemas5TypeIntegrationSchemas1 IntegrationSchemas5Type = "Integration_Schemas_1"
	IntegrationSchemas5TypeStr                 IntegrationSchemas5Type = "str"
	IntegrationSchemas5TypeNumber              IntegrationSchemas5Type = "number"
	IntegrationSchemas5TypeBoolean             IntegrationSchemas5Type = "boolean"
)

type IntegrationSchemas5 struct {
	IntegrationSchemas1 *IntegrationSchemas1 `queryParam:"inline" union:"member"`
	Str                 *string              `queryParam:"inline" union:"member"`
	Number              *float64             `queryParam:"inline" union:"member"`
	Boolean             *bool                `queryParam:"inline" union:"member"`

	Type IntegrationSchemas5Type
}

func CreateIntegrationSchemas5IntegrationSchemas1(integrationSchemas1 IntegrationSchemas1) IntegrationSchemas5 {
	typ := IntegrationSchemas5TypeIntegrationSchemas1

	return IntegrationSchemas5{
		IntegrationSchemas1: &integrationSchemas1,
		Type:                typ,
	}
}

func CreateIntegrationSchemas5Str(str string) IntegrationSchemas5 {
	typ := IntegrationSchemas5TypeStr

	return IntegrationSchemas5{
		Str:  &str,
		Type: typ,
	}
}

func CreateIntegrationSchemas5Number(number float64) IntegrationSchemas5 {
	typ := IntegrationSchemas5TypeNumber

	return IntegrationSchemas5{
		Number: &number,
		Type:   typ,
	}
}

func CreateIntegrationSchemas5Boolean(boolean bool) IntegrationSchemas5 {
	typ := IntegrationSchemas5TypeBoolean

	return IntegrationSchemas5{
		Boolean: &boolean,
		Type:    typ,
	}
}

func (u *IntegrationSchemas5) UnmarshalJSON(data []byte) error {

	var integrationSchemas1 IntegrationSchemas1 = IntegrationSchemas1{}
	if err := utils.UnmarshalJSON(data, &integrationSchemas1, "", true, nil); err == nil {
		u.IntegrationSchemas1 = &integrationSchemas1
		u.Type = IntegrationSchemas5TypeIntegrationSchemas1
		return nil
	}

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		u.Str = &str
		u.Type = IntegrationSchemas5TypeStr
		return nil
	}

	var number float64 = float64(0)
	if err := utils.UnmarshalJSON(data, &number, "", true, nil); err == nil {
		u.Number = &number
		u.Type = IntegrationSchemas5TypeNumber
		return nil
	}

	var boolean bool = false
	if err := utils.UnmarshalJSON(data, &boolean, "", true, nil); err == nil {
		u.Boolean = &boolean
		u.Type = IntegrationSchemas5TypeBoolean
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for IntegrationSchemas5", string(data))
}

func (u IntegrationSchemas5) MarshalJSON() ([]byte, error) {
	if u.IntegrationSchemas1 != nil {
		return utils.MarshalJSON(u.IntegrationSchemas1, "", true)
	}

	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.Number != nil {
		return utils.MarshalJSON(u.Number, "", true)
	}

	if u.Boolean != nil {
		return utils.MarshalJSON(u.Boolean, "", true)
	}

	return nil, errors.New("could not marshal union type IntegrationSchemas5: all fields are null")
}

type PartnershipType string

const (
	PartnershipTypeMapOfAny                   PartnershipType = "mapOfAny"
	PartnershipTypeStr                        PartnershipType = "str"
	PartnershipTypeNumber                     PartnershipType = "number"
	PartnershipTypeBoolean                    PartnershipType = "boolean"
	PartnershipTypeArrayOfIntegrationSchemas5 PartnershipType = "arrayOfIntegrationSchemas5"
)

type Partnership struct {
	MapOfAny                   map[string]any        `queryParam:"inline" union:"member"`
	Str                        *string               `queryParam:"inline" union:"member"`
	Number                     *float64              `queryParam:"inline" union:"member"`
	Boolean                    *bool                 `queryParam:"inline" union:"member"`
	ArrayOfIntegrationSchemas5 []IntegrationSchemas5 `queryParam:"inline" union:"member"`

	Type PartnershipType
}

func CreatePartnershipMapOfAny(mapOfAny map[string]any) Partnership {
	typ := PartnershipTypeMapOfAny

	return Partnership{
		MapOfAny: mapOfAny,
		Type:     typ,
	}
}

func CreatePartnershipStr(str string) Partnership {
	typ := PartnershipTypeStr

	return Partnership{
		Str:  &str,
		Type: typ,
	}
}

func CreatePartnershipNumber(number float64) Partnership {
	typ := PartnershipTypeNumber

	return Partnership{
		Number: &number,
		Type:   typ,
	}
}

func CreatePartnershipBoolean(boolean bool) Partnership {
	typ := PartnershipTypeBoolean

	return Partnership{
		Boolean: &boolean,
		Type:    typ,
	}
}

func CreatePartnershipArrayOfIntegrationSchemas5(arrayOfIntegrationSchemas5 []IntegrationSchemas5) Partnership {
	typ := PartnershipTypeArrayOfIntegrationSchemas5

	return Partnership{
		ArrayOfIntegrationSchemas5: arrayOfIntegrationSchemas5,
		Type:                       typ,
	}
}

func (u *Partnership) UnmarshalJSON(data []byte) error {

	var mapOfAny map[string]any = map[string]any{}
	if err := utils.UnmarshalJSON(data, &mapOfAny, "", true, nil); err == nil {
		u.MapOfAny = mapOfAny
		u.Type = PartnershipTypeMapOfAny
		return nil
	}

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		u.Str = &str
		u.Type = PartnershipTypeStr
		return nil
	}

	var number float64 = float64(0)
	if err := utils.UnmarshalJSON(data, &number, "", true, nil); err == nil {
		u.Number = &number
		u.Type = PartnershipTypeNumber
		return nil
	}

	var boolean bool = false
	if err := utils.UnmarshalJSON(data, &boolean, "", true, nil); err == nil {
		u.Boolean = &boolean
		u.Type = PartnershipTypeBoolean
		return nil
	}

	var arrayOfIntegrationSchemas5 []IntegrationSchemas5 = []IntegrationSchemas5{}
	if err := utils.UnmarshalJSON(data, &arrayOfIntegrationSchemas5, "", true, nil); err == nil {
		u.ArrayOfIntegrationSchemas5 = arrayOfIntegrationSchemas5
		u.Type = PartnershipTypeArrayOfIntegrationSchemas5
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for Partnership", string(data))
}

func (u Partnership) MarshalJSON() ([]byte, error) {
	if u.MapOfAny != nil {
		return utils.MarshalJSON(u.MapOfAny, "", true)
	}

	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.Number != nil {
		return utils.MarshalJSON(u.Number, "", true)
	}

	if u.Boolean != nil {
		return utils.MarshalJSON(u.Boolean, "", true)
	}

	if u.ArrayOfIntegrationSchemas5 != nil {
		return utils.MarshalJSON(u.ArrayOfIntegrationSchemas5, "", true)
	}

	return nil, errors.New("could not marshal union type Partnership: all fields are null")
}

type IntegrationSchemasSaml1 struct {
}

func (i IntegrationSchemasSaml1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *IntegrationSchemasSaml1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, nil); err != nil {
		return err
	}
	return nil
}

type IntegrationSchemasSaml5Type string

const (
	IntegrationSchemasSaml5TypeIntegrationSchemasSaml1 IntegrationSchemasSaml5Type = "Integration_Schemas_saml_1"
	IntegrationSchemasSaml5TypeStr                     IntegrationSchemasSaml5Type = "str"
	IntegrationSchemasSaml5TypeNumber                  IntegrationSchemasSaml5Type = "number"
	IntegrationSchemasSaml5TypeBoolean                 IntegrationSchemasSaml5Type = "boolean"
)

type IntegrationSchemasSaml5 struct {
	IntegrationSchemasSaml1 *IntegrationSchemasSaml1 `queryParam:"inline" union:"member"`
	Str                     *string                  `queryParam:"inline" union:"member"`
	Number                  *float64                 `queryParam:"inline" union:"member"`
	Boolean                 *bool                    `queryParam:"inline" union:"member"`

	Type IntegrationSchemasSaml5Type
}

func CreateIntegrationSchemasSaml5IntegrationSchemasSaml1(integrationSchemasSaml1 IntegrationSchemasSaml1) IntegrationSchemasSaml5 {
	typ := IntegrationSchemasSaml5TypeIntegrationSchemasSaml1

	return IntegrationSchemasSaml5{
		IntegrationSchemasSaml1: &integrationSchemasSaml1,
		Type:                    typ,
	}
}

func CreateIntegrationSchemasSaml5Str(str string) IntegrationSchemasSaml5 {
	typ := IntegrationSchemasSaml5TypeStr

	return IntegrationSchemasSaml5{
		Str:  &str,
		Type: typ,
	}
}

func CreateIntegrationSchemasSaml5Number(number float64) IntegrationSchemasSaml5 {
	typ := IntegrationSchemasSaml5TypeNumber

	return IntegrationSchemasSaml5{
		Number: &number,
		Type:   typ,
	}
}

func CreateIntegrationSchemasSaml5Boolean(boolean bool) IntegrationSchemasSaml5 {
	typ := IntegrationSchemasSaml5TypeBoolean

	return IntegrationSchemasSaml5{
		Boolean: &boolean,
		Type:    typ,
	}
}

func (u *IntegrationSchemasSaml5) UnmarshalJSON(data []byte) error {

	var integrationSchemasSaml1 IntegrationSchemasSaml1 = IntegrationSchemasSaml1{}
	if err := utils.UnmarshalJSON(data, &integrationSchemasSaml1, "", true, nil); err == nil {
		u.IntegrationSchemasSaml1 = &integrationSchemasSaml1
		u.Type = IntegrationSchemasSaml5TypeIntegrationSchemasSaml1
		return nil
	}

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		u.Str = &str
		u.Type = IntegrationSchemasSaml5TypeStr
		return nil
	}

	var number float64 = float64(0)
	if err := utils.UnmarshalJSON(data, &number, "", true, nil); err == nil {
		u.Number = &number
		u.Type = IntegrationSchemasSaml5TypeNumber
		return nil
	}

	var boolean bool = false
	if err := utils.UnmarshalJSON(data, &boolean, "", true, nil); err == nil {
		u.Boolean = &boolean
		u.Type = IntegrationSchemasSaml5TypeBoolean
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for IntegrationSchemasSaml5", string(data))
}

func (u IntegrationSchemasSaml5) MarshalJSON() ([]byte, error) {
	if u.IntegrationSchemasSaml1 != nil {
		return utils.MarshalJSON(u.IntegrationSchemasSaml1, "", true)
	}

	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.Number != nil {
		return utils.MarshalJSON(u.Number, "", true)
	}

	if u.Boolean != nil {
		return utils.MarshalJSON(u.Boolean, "", true)
	}

	return nil, errors.New("could not marshal union type IntegrationSchemasSaml5: all fields are null")
}

type SamlType string

const (
	SamlTypeMapOfAny                       SamlType = "mapOfAny"
	SamlTypeStr                            SamlType = "str"
	SamlTypeNumber                         SamlType = "number"
	SamlTypeBoolean                        SamlType = "boolean"
	SamlTypeArrayOfIntegrationSchemasSaml5 SamlType = "arrayOfIntegrationSchemasSaml5"
)

type Saml struct {
	MapOfAny                       map[string]any            `queryParam:"inline" union:"member"`
	Str                            *string                   `queryParam:"inline" union:"member"`
	Number                         *float64                  `queryParam:"inline" union:"member"`
	Boolean                        *bool                     `queryParam:"inline" union:"member"`
	ArrayOfIntegrationSchemasSaml5 []IntegrationSchemasSaml5 `queryParam:"inline" union:"member"`

	Type SamlType
}

func CreateSamlMapOfAny(mapOfAny map[string]any) Saml {
	typ := SamlTypeMapOfAny

	return Saml{
		MapOfAny: mapOfAny,
		Type:     typ,
	}
}

func CreateSamlStr(str string) Saml {
	typ := SamlTypeStr

	return Saml{
		Str:  &str,
		Type: typ,
	}
}

func CreateSamlNumber(number float64) Saml {
	typ := SamlTypeNumber

	return Saml{
		Number: &number,
		Type:   typ,
	}
}

func CreateSamlBoolean(boolean bool) Saml {
	typ := SamlTypeBoolean

	return Saml{
		Boolean: &boolean,
		Type:    typ,
	}
}

func CreateSamlArrayOfIntegrationSchemasSaml5(arrayOfIntegrationSchemasSaml5 []IntegrationSchemasSaml5) Saml {
	typ := SamlTypeArrayOfIntegrationSchemasSaml5

	return Saml{
		ArrayOfIntegrationSchemasSaml5: arrayOfIntegrationSchemasSaml5,
		Type:                           typ,
	}
}

func (u *Saml) UnmarshalJSON(data []byte) error {

	var mapOfAny map[string]any = map[string]any{}
	if err := utils.UnmarshalJSON(data, &mapOfAny, "", true, nil); err == nil {
		u.MapOfAny = mapOfAny
		u.Type = SamlTypeMapOfAny
		return nil
	}

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		u.Str = &str
		u.Type = SamlTypeStr
		return nil
	}

	var number float64 = float64(0)
	if err := utils.UnmarshalJSON(data, &number, "", true, nil); err == nil {
		u.Number = &number
		u.Type = SamlTypeNumber
		return nil
	}

	var boolean bool = false
	if err := utils.UnmarshalJSON(data, &boolean, "", true, nil); err == nil {
		u.Boolean = &boolean
		u.Type = SamlTypeBoolean
		return nil
	}

	var arrayOfIntegrationSchemasSaml5 []IntegrationSchemasSaml5 = []IntegrationSchemasSaml5{}
	if err := utils.UnmarshalJSON(data, &arrayOfIntegrationSchemasSaml5, "", true, nil); err == nil {
		u.ArrayOfIntegrationSchemasSaml5 = arrayOfIntegrationSchemasSaml5
		u.Type = SamlTypeArrayOfIntegrationSchemasSaml5
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for Saml", string(data))
}

func (u Saml) MarshalJSON() ([]byte, error) {
	if u.MapOfAny != nil {
		return utils.MarshalJSON(u.MapOfAny, "", true)
	}

	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.Number != nil {
		return utils.MarshalJSON(u.Number, "", true)
	}

	if u.Boolean != nil {
		return utils.MarshalJSON(u.Boolean, "", true)
	}

	if u.ArrayOfIntegrationSchemasSaml5 != nil {
		return utils.MarshalJSON(u.ArrayOfIntegrationSchemasSaml5, "", true)
	}

	return nil, errors.New("could not marshal union type Saml: all fields are null")
}

type IntegrationSchemasSandbox1 struct {
}

func (i IntegrationSchemasSandbox1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *IntegrationSchemasSandbox1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, nil); err != nil {
		return err
	}
	return nil
}

type IntegrationSchemasSandbox5Type string

const (
	IntegrationSchemasSandbox5TypeIntegrationSchemasSandbox1 IntegrationSchemasSandbox5Type = "Integration_Schemas_sandbox_1"
	IntegrationSchemasSandbox5TypeStr                        IntegrationSchemasSandbox5Type = "str"
	IntegrationSchemasSandbox5TypeNumber                     IntegrationSchemasSandbox5Type = "number"
	IntegrationSchemasSandbox5TypeBoolean                    IntegrationSchemasSandbox5Type = "boolean"
)

type IntegrationSchemasSandbox5 struct {
	IntegrationSchemasSandbox1 *IntegrationSchemasSandbox1 `queryParam:"inline" union:"member"`
	Str                        *string                     `queryParam:"inline" union:"member"`
	Number                     *float64                    `queryParam:"inline" union:"member"`
	Boolean                    *bool                       `queryParam:"inline" union:"member"`

	Type IntegrationSchemasSandbox5Type
}

func CreateIntegrationSchemasSandbox5IntegrationSchemasSandbox1(integrationSchemasSandbox1 IntegrationSchemasSandbox1) IntegrationSchemasSandbox5 {
	typ := IntegrationSchemasSandbox5TypeIntegrationSchemasSandbox1

	return IntegrationSchemasSandbox5{
		IntegrationSchemasSandbox1: &integrationSchemasSandbox1,
		Type:                       typ,
	}
}

func CreateIntegrationSchemasSandbox5Str(str string) IntegrationSchemasSandbox5 {
	typ := IntegrationSchemasSandbox5TypeStr

	return IntegrationSchemasSandbox5{
		Str:  &str,
		Type: typ,
	}
}

func CreateIntegrationSchemasSandbox5Number(number float64) IntegrationSchemasSandbox5 {
	typ := IntegrationSchemasSandbox5TypeNumber

	return IntegrationSchemasSandbox5{
		Number: &number,
		Type:   typ,
	}
}

func CreateIntegrationSchemasSandbox5Boolean(boolean bool) IntegrationSchemasSandbox5 {
	typ := IntegrationSchemasSandbox5TypeBoolean

	return IntegrationSchemasSandbox5{
		Boolean: &boolean,
		Type:    typ,
	}
}

func (u *IntegrationSchemasSandbox5) UnmarshalJSON(data []byte) error {

	var integrationSchemasSandbox1 IntegrationSchemasSandbox1 = IntegrationSchemasSandbox1{}
	if err := utils.UnmarshalJSON(data, &integrationSchemasSandbox1, "", true, nil); err == nil {
		u.IntegrationSchemasSandbox1 = &integrationSchemasSandbox1
		u.Type = IntegrationSchemasSandbox5TypeIntegrationSchemasSandbox1
		return nil
	}

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		u.Str = &str
		u.Type = IntegrationSchemasSandbox5TypeStr
		return nil
	}

	var number float64 = float64(0)
	if err := utils.UnmarshalJSON(data, &number, "", true, nil); err == nil {
		u.Number = &number
		u.Type = IntegrationSchemasSandbox5TypeNumber
		return nil
	}

	var boolean bool = false
	if err := utils.UnmarshalJSON(data, &boolean, "", true, nil); err == nil {
		u.Boolean = &boolean
		u.Type = IntegrationSchemasSandbox5TypeBoolean
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for IntegrationSchemasSandbox5", string(data))
}

func (u IntegrationSchemasSandbox5) MarshalJSON() ([]byte, error) {
	if u.IntegrationSchemasSandbox1 != nil {
		return utils.MarshalJSON(u.IntegrationSchemasSandbox1, "", true)
	}

	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.Number != nil {
		return utils.MarshalJSON(u.Number, "", true)
	}

	if u.Boolean != nil {
		return utils.MarshalJSON(u.Boolean, "", true)
	}

	return nil, errors.New("could not marshal union type IntegrationSchemasSandbox5: all fields are null")
}

type SandboxType string

const (
	SandboxTypeMapOfAny                          SandboxType = "mapOfAny"
	SandboxTypeStr                               SandboxType = "str"
	SandboxTypeNumber                            SandboxType = "number"
	SandboxTypeBoolean                           SandboxType = "boolean"
	SandboxTypeArrayOfIntegrationSchemasSandbox5 SandboxType = "arrayOfIntegrationSchemasSandbox5"
)

type Sandbox struct {
	MapOfAny                          map[string]any               `queryParam:"inline" union:"member"`
	Str                               *string                      `queryParam:"inline" union:"member"`
	Number                            *float64                     `queryParam:"inline" union:"member"`
	Boolean                           *bool                        `queryParam:"inline" union:"member"`
	ArrayOfIntegrationSchemasSandbox5 []IntegrationSchemasSandbox5 `queryParam:"inline" union:"member"`

	Type SandboxType
}

func CreateSandboxMapOfAny(mapOfAny map[string]any) Sandbox {
	typ := SandboxTypeMapOfAny

	return Sandbox{
		MapOfAny: mapOfAny,
		Type:     typ,
	}
}

func CreateSandboxStr(str string) Sandbox {
	typ := SandboxTypeStr

	return Sandbox{
		Str:  &str,
		Type: typ,
	}
}

func CreateSandboxNumber(number float64) Sandbox {
	typ := SandboxTypeNumber

	return Sandbox{
		Number: &number,
		Type:   typ,
	}
}

func CreateSandboxBoolean(boolean bool) Sandbox {
	typ := SandboxTypeBoolean

	return Sandbox{
		Boolean: &boolean,
		Type:    typ,
	}
}

func CreateSandboxArrayOfIntegrationSchemasSandbox5(arrayOfIntegrationSchemasSandbox5 []IntegrationSchemasSandbox5) Sandbox {
	typ := SandboxTypeArrayOfIntegrationSchemasSandbox5

	return Sandbox{
		ArrayOfIntegrationSchemasSandbox5: arrayOfIntegrationSchemasSandbox5,
		Type:                              typ,
	}
}

func (u *Sandbox) UnmarshalJSON(data []byte) error {

	var mapOfAny map[string]any = map[string]any{}
	if err := utils.UnmarshalJSON(data, &mapOfAny, "", true, nil); err == nil {
		u.MapOfAny = mapOfAny
		u.Type = SandboxTypeMapOfAny
		return nil
	}

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		u.Str = &str
		u.Type = SandboxTypeStr
		return nil
	}

	var number float64 = float64(0)
	if err := utils.UnmarshalJSON(data, &number, "", true, nil); err == nil {
		u.Number = &number
		u.Type = SandboxTypeNumber
		return nil
	}

	var boolean bool = false
	if err := utils.UnmarshalJSON(data, &boolean, "", true, nil); err == nil {
		u.Boolean = &boolean
		u.Type = SandboxTypeBoolean
		return nil
	}

	var arrayOfIntegrationSchemasSandbox5 []IntegrationSchemasSandbox5 = []IntegrationSchemasSandbox5{}
	if err := utils.UnmarshalJSON(data, &arrayOfIntegrationSchemasSandbox5, "", true, nil); err == nil {
		u.ArrayOfIntegrationSchemasSandbox5 = arrayOfIntegrationSchemasSandbox5
		u.Type = SandboxTypeArrayOfIntegrationSchemasSandbox5
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for Sandbox", string(data))
}

func (u Sandbox) MarshalJSON() ([]byte, error) {
	if u.MapOfAny != nil {
		return utils.MarshalJSON(u.MapOfAny, "", true)
	}

	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.Number != nil {
		return utils.MarshalJSON(u.Number, "", true)
	}

	if u.Boolean != nil {
		return utils.MarshalJSON(u.Boolean, "", true)
	}

	if u.ArrayOfIntegrationSchemasSandbox5 != nil {
		return utils.MarshalJSON(u.ArrayOfIntegrationSchemasSandbox5, "", true)
	}

	return nil, errors.New("could not marshal union type Sandbox: all fields are null")
}

// Integration - Informational object for supported integrations.
type Integration struct {
	ActiveHealthyConnections *float64 `json:"active_healthy_connections,omitempty"`
	API                      *API     `json:"api,omitempty"`
	APIDocsURL               *string  `json:"api_docs_url,omitempty"`
	Beta                     *bool    `json:"beta,omitempty"`
	// The categories of support solutions that this integration has
	Categories           []PropertyIntegrationCategories `json:"categories"`
	Color                *string                         `json:"color,omitempty"`
	CreatedAt            *string                         `json:"created_at,omitempty"`
	Description          *string                         `json:"description,omitempty"`
	FaIcon               *string                         `json:"fa_icon,omitempty"`
	Featured             *bool                           `json:"featured,omitempty"`
	InProgress           *bool                           `json:"in_progress,omitempty"`
	IsActive             *bool                           `json:"is_active,omitempty"`
	LogoURL              *string                         `json:"logo_url,omitempty"`
	Name                 string                          `json:"name"`
	Partnership          *Partnership                    `json:"partnership,omitempty"`
	Popularity           *float64                        `json:"popularity,omitempty"`
	RateLimitDescription *string                         `json:"rate_limit_description,omitempty"`
	Saml                 *Saml                           `json:"saml,omitempty"`
	Sandbox              *Sandbox                        `json:"sandbox,omitempty"`
	Support              map[string]IntegrationSupport   `json:"support,omitempty"`
	TestedAt             *time.Time                      `json:"tested_at,omitempty"`
	TextColor            *string                         `json:"text_color,omitempty"`
	// instructions for the user on how to find the token/key
	TokenInstructions []string `json:"token_instructions,omitempty"`
	// if auth_types = 'token'
	TokenNames []string `json:"token_names,omitempty"`
	Type       string   `json:"type"`
	UpdatedAt  *string  `json:"updated_at,omitempty"`
	WebURL     *string  `json:"web_url,omitempty"`
}

func (i Integration) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *Integration) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (i *Integration) GetActiveHealthyConnections() *float64 {
	if i == nil {
		return nil
	}
	return i.ActiveHealthyConnections
}

func (i *Integration) GetAPI() *API {
	if i == nil {
		return nil
	}
	return i.API
}

func (i *Integration) GetAPIDocsURL() *string {
	if i == nil {
		return nil
	}
	return i.APIDocsURL
}

func (i *Integration) GetBeta() *bool {
	if i == nil {
		return nil
	}
	return i.Beta
}

func (i *Integration) GetCategories() []PropertyIntegrationCategories {
	if i == nil {
		return []PropertyIntegrationCategories{}
	}
	return i.Categories
}

func (i *Integration) GetColor() *string {
	if i == nil {
		return nil
	}
	return i.Color
}

func (i *Integration) GetCreatedAt() *string {
	if i == nil {
		return nil
	}
	return i.CreatedAt
}

func (i *Integration) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *Integration) GetFaIcon() *string {
	if i == nil {
		return nil
	}
	return i.FaIcon
}

func (i *Integration) GetFeatured() *bool {
	if i == nil {
		return nil
	}
	return i.Featured
}

func (i *Integration) GetInProgress() *bool {
	if i == nil {
		return nil
	}
	return i.InProgress
}

func (i *Integration) GetIsActive() *bool {
	if i == nil {
		return nil
	}
	return i.IsActive
}

func (i *Integration) GetLogoURL() *string {
	if i == nil {
		return nil
	}
	return i.LogoURL
}

func (i *Integration) GetName() string {
	if i == nil {
		return ""
	}
	return i.Name
}

func (i *Integration) GetPartnership() *Partnership {
	if i == nil {
		return nil
	}
	return i.Partnership
}

func (i *Integration) GetPopularity() *float64 {
	if i == nil {
		return nil
	}
	return i.Popularity
}

func (i *Integration) GetRateLimitDescription() *string {
	if i == nil {
		return nil
	}
	return i.RateLimitDescription
}

func (i *Integration) GetSaml() *Saml {
	if i == nil {
		return nil
	}
	return i.Saml
}

func (i *Integration) GetSandbox() *Sandbox {
	if i == nil {
		return nil
	}
	return i.Sandbox
}

func (i *Integration) GetSupport() map[string]IntegrationSupport {
	if i == nil {
		return nil
	}
	return i.Support
}

func (i *Integration) GetTestedAt() *time.Time {
	if i == nil {
		return nil
	}
	return i.TestedAt
}

func (i *Integration) GetTextColor() *string {
	if i == nil {
		return nil
	}
	return i.TextColor
}

func (i *Integration) GetTokenInstructions() []string {
	if i == nil {
		return nil
	}
	return i.TokenInstructions
}

func (i *Integration) GetTokenNames() []string {
	if i == nil {
		return nil
	}
	return i.TokenNames
}

func (i *Integration) GetType() string {
	if i == nil {
		return ""
	}
	return i.Type
}

func (i *Integration) GetUpdatedAt() *string {
	if i == nil {
		return nil
	}
	return i.UpdatedAt
}

func (i *Integration) GetWebURL() *string {
	if i == nil {
		return nil
	}
	return i.WebURL
}
